---
title: "The Current State of R Tools for Nonlinear Least Squares Modeling"
author:
- John C. Nash \thanks{ retired professor, Telfer School of Management, University
  of Ottawa}
- Arkajyoti Bhattacharjee \thanks{Department of Mathematics and Statistics, Indian
  Institute of Technology, Kanpur}
date: "2023-7-16"
output: 
  pdf_document:
    keep_tex: yes
    toc: no
  word_document:
    toc: no
bibliography: ./StateOfRToolsForNLS.bib
link-citations: yes
linkcolor: red
urlcolor: blue
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
## require(bookdown) # language engine to display text - does not seem necessary
```

## Abstract

Our Google Summer of Code project "Improvements to `nls()`" considered the features 
and limitations of the R function `nls()` with the aim 
of improving and rationalizing R tools for nonlinear regression.
The rich features of `nls()` are weakened by several deficiencies and
inconsistencies such as a lack of stabilization of the Gauss-Newton solver.
Further considerations are the usability and  maintainability of
the code base that provides the functionality `nls()` offers.
Various packages, in particular `nlsr` (@nlsr2023manual), provide alternative capabilities.
We consider the differences in goals, approaches, and features of
different tools for nonlinear least squares modeling in R. Discussion of 
these matters is relevant to improving R generally as well as its 
nonlinear estimation tools.

## The `nls()` function

`nls()` is the tool for estimating nonlinear statistical models in base R, the 
primary software distribution
from the Comprehensive R Archive Network (CRAN).
Users do not have to request that `nls()` be loaded.
The function dates to the 1980s and the work related to @bateswatts and others 
in the S programming language.

The `nls()` function has a remarkable and comprehensive set of capabilities for 
estimating nonlinear models that are expressed as **formulas**. In particular, we
note that it

- handles formulas that include R functions, even ones that call calculations in
  other programming languages;
- allows data to be weighted or subset;
- can estimate bound-constrained parameters;
- provides a mechanism for handling partially linear models;
- permits parameters to be indexed over a set of related data;
- produces measures of variability (i.e., standard error estimates) for the 
estimated parameters;
- has related profiling capabilities for exploring the likelihood surface as 
parameters are changed;
- links to many pre-coded (`selfStart`) models that do not require
  initial parameter values.

With such a range of features and long history, the code has become untidy 
and overly patched, difficult to maintain, and its underlying methods could
be improved. Various workers have developed packages to overcome these 
concerns, and we will address some of these here.

## Scope of our comparison

Our Google Summer of Code project for 2021, "Improvements to `nls()`"
had the goal of providing a version of the code that would address some
of the deficiencies discovered over the long period that `nls()`
has been part of R. However, it was also critical to preserve legacy
functionality, and we did not achieve a result that provided desired
improvements and preserved legacy results simultaneously. On the other hand, working
with `nls()` suggested ways package `nlsr` could be improved
in features, while also revealing how it has a very different internal
structure and design.

The primary goal of this paper is to present some of these issues,
with a limited consideration of some other R tools that exist for 
nonlinear least squares calculations. We hope to encourage
others to engage, possibly with us, to find ways to bring improvements and
to consolidate tools where reasonable. We want to ease the task of users
in choosing which tools to use. Unfortunately, it is simpler to create 
new packages than to bring together and simplify existing ones.

### Tools considered

Besides the base-R `nls()` function, we consider some packages that 
are available in the CRAN repository. Of these, we will pay particular 
attention to **nlsr** (@nlsr2023manual),
**minpack.lm** (@minpacklm12), and **gslnls** (@gslnls23) which are
general nonlinear least-squares solvers. We will 
not pursue tools in the Bioconductor (@Bioconductor) 
collection, nor those on repositories such as 
GitHub and Gitlab.

## An illustrative example

The Hobbs weed infestation problem (@cnm79 [page 120]) is a growth curve modeling 
task that seems straightforward, but is quite nasty. Its very succinct statement 
provides the "short reproducible example" much requested on R mailing lists. 
This is a real problem from a field researcher, though the units of measurement
and background information are not available. The data and graph follow.

```{r ex01, echo=TRUE}
weed <- c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
          38.558, 50.156, 62.948, 75.995, 91.972)
tt <- 1:12
weeddf <- data.frame(tt, weed)
plot(weeddf, main="Hobbs weed infestation data")
```

Three suggested models for this data are (with names to allow for easy reference)

**Logistic3U**:
$$  y \approx  b_1 / (1 + b_2 * exp(- b_3 * t)) $$

**Logistic3S**:
$$ y \approx  100 * c_1 / (1 + 10 * c_2 * exp(- 0.1 * c_3 * t)) $$

**Logistic3T**:
$$ y \approx Asym / (1 + exp((xmid - t)/scal)) $$

where we will use `weed` for $y$ and `tt` for $t$. 
The functions above are equivalent, but the first is generally more awkward
to solve numerically due to its poor scaling. The parameters of the three forms
are related as follows:

$$   Asym =  b_1 = 100 * c_1 $$
$$ exp(xmid/scal)  =  b_2 = 10 * c_2 $$
$$ 1/scal  =  b_3 $$
To allow for simpler discussion, let us say that the parameters form a (named) vector
$p$ and the model function is called $model(p)$. The residuals can be written
either as $r_1 = y - model(p)$ or $r = model(p) - y$
since their sum of squares has an identical value. The second form
avoids a potential sign error if we need to evaluate derivatives. 

We wish to minimize the sum of squared residuals, which is our loss (or objective) function. 
Starting with some guess for the parameters, we aim to alter these parameters to obtain a smaller
loss function. We then iterate until we can make no further progress.

Let us consider there are $n$ parameters and $m$ residuals. 
The loss function is 
$$ S(p) = r' r = \sum_{i=1}^m { r_i^2 }$$
The gradient of $S(p)$ is
$$ g = 2 * J' r$$
where the Jacobian $J$ is given by elements
$$ J_{i,j} = \partial r_i / \partial p_j $$
and the Hessian is defined by elements
$$ H_{i,j} = \partial ^2 S(p) / {\partial p_i \partial p_j} $$
If we expand the Hessian for nonlinear least squares problems, we find
$$  H_{i,j}/2 = \sum_{k = 1}^m{ J_{k,i} J_{k,j}}  + \sum_{k = 1}^m {r_k * \partial{r_k}/{\partial p_i \partial p_j}}$$
Let us use $D_{i,j}$ for the elements of the second term of this expression.
What is generally called **Newton's method** for function minimization tries
to set the gradient to zero (to find a stationary point of the function $S(p)$).
This leads to **Newton's equation**
$$ H \delta  = -g $$
Given a set of parameters $p$, which provide $H$ and $g$, we solve this equation for $\delta$, adjust $p$
to $p + \delta$ and iterate, hopefully to converge on a solution. 
Applying this to a sum of squares problem gives
$$ H \delta / 2 = (J'J + D) \delta = - J' r$$
In this expression, only the elements of $D$ have second partial derivatives. 
Gauss, attempting to model planetary orbits, had small residuals, and noted
that these multiplied the second partial derivatives of $r$, so he approximated
$$ H / 2 \approx J' J$$
by assuming $D \approx 0$. This results in the Gauss-Newton method where we
solve 
$$ J' J \delta = - J' r$$
though we can avoid some loss of accuracy by not forming the inner product matrix
$J' J$ and solving the linear least squares matrix problem 
$$ J \delta \approx -r $$
by one of several matrix decomposition methods. On the other hand, when $m >> n$,
the matrix $J' J$ uses much less storage than $J$.

In reality, there are many problems where $D$ should not be ignored, but the work
to compute it precisely is considerable. Many work-arounds have been 
proposed, of which the Levenberg-Marquardt stabilization 
(@Levenberg1944, @Marquardt1963) is
the most commonly used. For convenience, we will use "Marquardt", as we believe he
first incorporated the ideas into a practical computer program. 

The usual suggestion is that $D$ be replaced by a multiple of the unit matrix or else
a multiple of the diagonal part of $J' J$. In low precision, some elements of 
$J' J$ could underflow to zero (@jn77ima), and a linear combination of both
choices is an effective compromise. Various choices for
$D$, as well as a possible line search along the
direction $\delta$ rather than a unit step (@Hartley1961), 
give rise to several variant
algorithms. "Marquardt's method" is a family of methods. Fortunately, most choices
work well.

### Problem setup

Let us specify in R the three model formulas and set some starting
values for parameters. These starting points are not equivalent and
are deliberately crude choices. Workers performing many calculations 
of a similar nature should try to provide good starting points to reduce
computation time and avoid finding a false solution.
  
```{r ex02set, echo=TRUE}
# model formulas
frmu <- weed ~ b1 / (1 + b2 * exp(-b3 * tt))
frms <- weed ~ 100* c1 / (1 + 10 * c2 * exp(-0.1 *c3 * tt))
frmt <- weed ~ Asym / (1 + exp((xmid - tt) / scal))
#
# Starting parameter sets
stu1<-c(b1 =1, b2 = 1, b3 = 1)
sts1<-c(c1 = 1, c2 = 1, c3 = 1)
stt1<-c(Asym = 1, xmid = 1, scal = 1)
```

One of the useful features of `nls()` is the possibility of a `selfStart` model,
where starting parameter values are not required. However, if a `selfStart` model 
is not available, `nls()` sets all the starting parameters 
to 1. This is tolerable, but could be improved by using a set of values
that are all slightly different, which, in the case of the example 
model $y \,\sim\, a \,*\, exp(-b \,*\, x) + c\,*\,exp(-d \,*\, x)$
would avoid a singular Jacobian because $b$ and $d$ were equal in value. 
Program modifications to give a sequence like  1.0, 1.1, 1.2, 1.3 for the four 
parameters are fairly obvious. 

It is also possible to provide R functions for the residual and Jacobian.
`nls()` is not well-suited to using such a formulation, but `nlsr::nlfb()`
and `minpack.lm::nls.lm()` work specifically with such a formulation.
This is usually more work for the user if the formula setup is possible.
To illustrate, we show the functions for the unscaled 3 parameter logistic.

```{r ex02fn, echo=TRUE}
# Logistic3U
hobbs.res  <-  function(x){ # scaled Hobbs weeds problem -- residual
  # This variant uses looping
  if(length(x) != 3) stop("hobbs.res -- parameter vector n!=3")
  y  <-  c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 
           38.558, 50.156, 62.948, 75.995, 91.972)
  tt  <-  1:12
  res  <-  x[1] / (1 + x[2] * exp(-x[3] * tt)) - y
}

hobbs.jac  <-  function(x) { # scaled Hobbs weeds problem -- Jacobian
  jj  <-  matrix(0.0, 12, 3)
  tt  <-  1:12
  yy  <-  exp(-x[3] * tt)
  zz  <-  1.0 / (1 + x[2] * yy)
  jj[tt,1]   <-   zz
  jj[tt,2]   <-   -x[1] * zz * zz * yy
  jj[tt,3]   <-   x[1] * zz * zz * yy * x[2] * tt
  attr(jj, "gradient") <- jj
  jj
}
```

## Estimation of models specified as formulas

Using a formula specification was a principal advantage made
with `nls()` when it became available in S sometime in the 1980s. It uses a
Gauss-Newton (i.e., unstabilized) iteration with a step reduction line
search (@Hartley1961). This works very efficiently as long as $J$ is not ill-conditioned.
Below we see the default `nls()` algorithm does poorly on the example problem. 
To save page space, we use 1-line result display functions from package `nlsr`, 
namely `pnls()` and `pshort()`.

```{r shortforms, echo=FALSE}
library(nlsr)
library(minpack.lm)
```

```{r ex02nls}
unls1<-try(nls(formula = frmu, start = stu1, data = weeddf))
snls1<-try(nls(formula = frms, start = sts1, data = weeddf))
tnls1<-try(nls(formula = frmt, start = stt1, data = weeddf))
```

Here we see the infamous "singular gradient" termination message of `nls()`. 
Technically, it is the Jacobian that is singular, but R does not distinguish scalar 
and vector functions, which yield partial derivatives that are a gradient or Jacobian 
respectively.

`nls()` also offers the option of using the "port" library algorithm
choice (@FoxHallSchryer1978). There is a warning in the `nls()` documentation that
this "appears unfinished", but it is successful in solving all three cases.

```{r ex02nlsport}
unls1p<-try(nls(formula = frmu, start = stu1, data = weeddf, algorithm = "port"))
pnls(unls1p)
snls1p<-try(nls(formula = frms, start = sts1, data = weeddf, algorithm = "port"))
pnls(snls1p)
tnls1p<-try(nls(formula = frmt, start = stt1, data = weeddf, algorithm = "port"))
pnls(tnls1p)
```


### Solution attempts with nlsr

```{r ex02nlsr}
unlx1 <- try(nlxb(formula = frmu, start = stu1, data = weeddf))
print(unlx1) 
snlx1 <- try(nlxb(formula = frms, start = sts1, data = weeddf))
pshort(snlx1) # a short-form output
tnlx1 <- try(nlxb(formula = frmt, start = stt1, data = weeddf))
pshort(tnlx1) # alternatively print(tnlx1)
```

Though we have found solutions, the Jacobian is essentially singular as 
shown by its singular
values. Note that these are **displayed** by package `nlsr` in a single column in
the output to provide a compact layout, but the values do **not** correspond to 
the individual parameters in 
whose row they appear; they are a property of the whole problem.


### Solution attempts with minpack.lm

```{r ex02minpack}
unlm1 <- try(nlsLM(formula = frmu, start = stu1, data = weeddf))
pnls(unlm1)  # Short form of output
snlm1 <- try(nlsLM(formula = frms, start = sts1, data = weeddf))
pnls(snlm1)
tnlm1 <- try(nlsLM(formula = frmt, start = stt1, data = weeddf))
pnls(tnlm1) # short form to give sum of squares, else use summary(tnlm1)
```

### Solution attempts with gslnls

```{r ex02gslnls}
library(gslnls)
ugslnls1 <- try(gsl_nls(fn = frmu, data = weeddf,  start = stu1))
pnls(ugslnls1) # to get sum of squares
sgslnls1 <- try(gsl_nls(fn = frms, data = weeddf,  start = sts1))
pnls(sgslnls1) # Use summary() to get display
tgslnls1 <- try(gsl_nls(fn = frmt, data = weeddf,  start = stt1))
pnls(tgslnls1) 
## Other algorithms
## tgslnls1a<-try(gsl_nls(fn = frmt, data = weeddf,  start = stt1, algorithm="lmaccel"))
## pnls(tgslnls1a) 
## tgslnls1d<-try(gsl_nls(fn = frmt, data = weeddf,  start = stt1, algorithm="dogleg"))
## pnls(tgslnls1d) 
## tgslnls1dd<-try(gsl_nls(fn = frmt, data = weeddf,  start = stt1, algorithm="ddogleg"))
## pnls(tgslnls1dd) 
## tgslnls1s2<-try(gsl_nls(fn = frmt, data = weeddf,  start = stt1, algorithm="subspace2D"))
## pnls(tgslnls1s2) 
```

While default `gsl_nls()` gives much of the same results as `nlsLM()`, uncommenting the
calls to the alternative algorithms shows it can get the global minimum with any of
these choices.

### Comparison notes for formula-setup solutions

`nlsr::nlxb()` uses `print()` to output standard errors and 
singular values of the Jacobian (for diagnostic purposes). By contrast, 
`minpack.lm::nlsLM()` and `nls()`
use `summary()`, which does not display the sum of squares, while `print()` 
gives the sum of squares, but not the standard error of the residuals.
Such behaviour is consistent with other modeling functions such as `lm()`.

The importance of the  singular values is to allow us to gauge how "nearly singular" 
the Jacobian is at the solution, and the ratio of the smallest to largest of the 
singular values is a simple but effective measure. The ratios are
4.6641e-05 for Logistic3U, 0.021022 for Logistic3S, and 0.001055 for
Logistic3T; so Logistic3S is the "least singular". 

The results from `nlsLM` and `gsl_nls` for the transformed model Logistic3T have a 
very large sum of squares, which may suggest that these programs have failed. 
Since `nls()`, `nlsLM()`, and `gsl_nls()` do not 
offer singular values, we need to extract the Jacobian and compute its
singular values. The following script shows how to do this, using as Jacobian 
the `gradient` element in the returned solution for these solvers.

```{r ex04singval, echo=TRUE, eval=TRUE}  
# for nlsLM
if (inherits(tnlm1, "try-error"))  {
   print("Cannot compute solution -- likely singular Jacobian")
 } else {  
   JtnlsLM <- tnlm1$m$gradient() # actually the Jacobian
   svd(JtnlsLM)$d # Singular values
}   
# for gsl_nls
if (inherits(tgslnls1, "try-error")) {
   cat("Cannot compute solution -- likely singular Jacobian")
} else {  
   JtnlsLM <- tgslnls1$m$gradient()
   svd(JtnlsLM)$d # Singular values
}   
```

We see that there are differences in detail, but the more important result is that
two out of three singular values are essentially 0. Our Jacobian is singular, and no 
method of the Gauss-Newton type should be able to continue. Indeed, from the 
parameters reported at this saddle point, `nlsr::nlxb()` cannot proceed. 

```{r ex05, echo=TRUE}  
stspecial <- c(Asym = 35.532,  xmid = 43376,  scal = -2935.4)
badstart <- nlxb(formula = frmt, start = stspecial, data = weeddf)
print(badstart)
```

We also 
note that changing the start to
```
stt2 <- c(Asym=1, xmid=1, scal=2)
```
allows both `nlsLM` and `gsl_nls` to find the minimum. `gsl_nls` also succeeds
when the particular form of the Marquardt stabilization is changed from the
default by the control setting `scale = "levenberg"`.

We consider the code inside package `nlsr` to be competently coded, 
with the advantage over `nls()` of the Levenberg-Marquardt stabilization 
in common with `minpack.lm` and `glsnls`. The success rate is high,
but `nlsr` has its premature terminations too. However, it provides 
diagnostic information in the form of the singular values of the Jacobian 
that allows us to try alternative starts, algorithms or programs in cases 
where there are indications of early termination.

## Functional specification of problems

Let us write a slightly modified form of the nonlinear least squares problem:

$$ S(p) = \sum_{i=1}^m { r_i(p)^2 }$$

R users are likely to think almost always that the functions $r_i$ are all of
the same form, differing in the details of the data they use. However, the
famous Rosenbrock banana-shaped valley (@Rosenbrock1960) has 
$$ r_1(p) = (1 - p_1)$$
$$ r_2(p) = 10 (p_2 - {p_1}^2)$$

Thus, there can be problems where the idea of a "model" or a "prediction"
makes no sense, though the nonlinear least squares problem is still
well-posed. In our code, we still refer to the functions as "residuals",
though this is purely a convenience.

We illustrate how to solve nonlinear least squares problems using
a function to define the residual. Note that `gsl_nls()` requires
a vector `y` that is the expected value of what we have called the
residual, but in this case is actually the model. `gsl_nls` uses 
a numerical approximation for the Jacobian if the argument `jac` 
is missing. Note functions `nlsr::pnls()` and `nslr::pnlslm()` for a 
1-line display of the results.

```{r exhobbsfn, eval=TRUE}
hobnlfb <- nlfb(start = stu1, resfn = hobbs.res, jacfn = hobbs.jac)
pshort(hobnlfb) # use print(hobnlfb) for more detail
hobnlm <- nls.lm(par = stu1, fn = hobbs.res, jac = hobbs.jac)
pnlslm(hobnlm)  
hobgsln <- gsl_nls(start = stu1, fn = hobbs.res, y = rep(0,12))
pnls(hobgsln)
hobgsl <- gsl_nls(start = stu1, fn = hobbs.res, y = rep(0,12), jac = hobbs.jac)
pnls(hobgsl) # using analytic Jacobian
```

## Design goals, termination tests, and output objects

The output object of `nlxb()` is smaller than the class `nls` object returned
by `nls()`, `nlsLM()`, and `gsl_nls()`. Package `nlsr` emphasizes the solution 
of the nonlinear least squares problem rather than the estimation of a nonlinear 
model that fits or explains the data. The object of class `nls` allows for 
a number of specialized modeling and diagnostic extensions. For compatibility, 
the `nlsr` package has the function `wrapnlsr()`, for which `nlsr()` is an alias,
that is intended for problems specified as formulas.
This uses `nlxb()` to find good parameters, then calls `nls()` to return the class 
`nls` object. Unless particular modeling features are needed, the use of 
`wrapnlsr()` is unnecessary and wasteful of resources.

The design goals of the different tools may also be revealed in the so-called
"convergence tests" for the iterative solvers. In the manual page for `nls()` 
in R 4.0.0 there was the warning:

>  *Do not use `nls` on artificial "zero-residual" data.*

with suggested addition of small perturbations to the data. This admits 
`nls()` could not solve well-posed problems unless data is polluted
with errors. Zero-residual problems are not always artificial,
since problems in function approximation and nonlinear equations can be 
approached with nonlinear least squares. Fortunately, a small adjustment
to the "termination test" for the **program**, rather than for the
"convergence" of the underlying **algorithm**, fixes the defect. The test
is the Relative Offset Convergence
Criterion (see @BatesWatts81). This scales an estimated reduction in the loss
function by its current value. If the loss function is very small, we are close
to a zero-divide. Adding a small quantity to the divisor avoids trouble. 
In 2021, one of us (J. Nash) proposed that `nls.control()` have an 
additional parameter `scaleOffset` with a default value of zero. Setting it to a 
small number -- 1.0 is a reasonable choice -- allows small-residual problems 
(i.e., near-exact fits) to be dealt with easily. We call this the
**safeguarded relative offset convergence criterion**, and it has been in `nlsr`
since it was introduced. The default value 
gives `nls()` its legacy behaviour. This improvement has been in the R distributed code 
since version 4.1.0.

Additional termination tests can be used. `nlsr` has a **small sum of 
squares** test (`smallsstest`) that compares the latest evaluated sum of squared
(weighted) residuals to `e4` times the initial sum of squares, where
`e4 <- (100 * .Machine$double.eps) ^ 4` is approximately 2.43e-55.

Termination after what may be considered excessive computation is also important.
`nls()` stops after `maxiter` "iterations". The meaning of "iteration" may require an 
examination of the code. `nlsr` terminates when the number of residual or 
Jacobian evaluations (`feval` and `jeval`) exceed set limits, and we prefer larger 
limits (`jemax = 5000` is the default) than the `maxiter = 50` of `nls()` to avoid 
stopping early. This may cause overly long run-times for `nlsr`, but our work often
involves problems that are sufficiently difficult that we want to be sure we do not
terminate early.

### Returned results of nls() and other tools

As mentioned, the output of `nls()` is an object of class "nls" which has a quite 
rich structure described in the manual file or revealed by applying the `str()` 
function to the result of `nls()`.

The complexity of this object is a challenge to users. Let us use 
`result` as the name of the returned object from `nls()`, `minpack.lm::nlsLM()` or,
`gslnls::gsl_nls()`. For example, the `data` return element is an R symbol. 
If the user's environment exists, which it may not, we could see this data 
via the syntax:
```
eval(parse(text = result$data))
```
However, since the evaluating environment might not exist, a better approach 
is to make the call to `nls()` 
with `model = TRUE`, which returns an element 
`model` which contains the data, and we can list its contents using
```
ls(result$model)
```
and if there is an element called `xdata`, then it can be accessed as
`result$model$xdata`.

By contrast, `nlsr::nlxb()` returns a much simpler structure of 11 items
in one level. Moreover, `nlxb` explicitly returns the sum of squares, the 
residual vector, Jacobian, and counts of evaluations, but does not include
the input data.

### When to compute ancillary information

Tools that produce a class `nls` output object create a rich set of functions
and structures that are then used in a variety of modeling tasks, including the
least squares solution. By contrast,
`nlsr` computes quantities as they are requested or needed, with additional
features in separate functions. For example, the singular values of the Jacobian 
are actually computed in the `print` and `summary` methods for the result. 
These two approaches
lead to different consequences for performance and how features are
provided. `nlsr` has antecedents in the methods of @cnm79, where storage for
data and programs was at a ridiculous premium in the small computers of the era.
Thus the code in `nlsr` is likely of value for workers to copy and modify
for customized tools, with code in R to support such uses.

## Jacobian calculation

Gauss-Newton/Marquardt methods all need a Jacobian matrix at each iteration. 
By default, `nlsr::nlxb()` will try to evaluate this using analytic 
expressions using symbolic and automatic differentiation tools. 
When using a formula specification of the model, `nls()`, `minpack.lm::nlsLM()`
and `gslnls::gsl_nls()` use a finite difference approximation to compute the
Jacobian, though `gsl_nls()` does have an option to attempt symbolic expressions.
Package `nlsr` provides, via appropriate calling syntax, four numeric approximation 
options for the Jacobian, with a further control `ndstep` for the size of the
step used in the approximation. These features are mainly to allow for investigation
of approximate derivatives. Regular users will rarely need them.

Using the `gradient` attribute of the output of the Jacobian function to hold
the Jacobian matrix lets us embed this in the **residual** function as well,
so that the call to `nlsr::nlfb()` can be made with the same name used for 
both residual and Jacobian function arguments. This programming trick saves a 
lot of trouble for the package developer, but it can be a nuisance for users 
trying to understand the code. 

As far as we can understand the logic in `nls()`, the Jacobian computation during
parameter estimation is carried out within the called C-language program
and its wrapper R code function `numericDeriv()`, part of
`./src/library/stats/R/nls.R`
in the R distribution source code. This is used to provide Jacobian information in 
the `nlsModel()` and `nlsModel.plinear()` functions, which are **not** exported for 
general use. `gsl_nls()` also appears to use `numericDeriv()`. 

`numericDeriv()` uses a 
simple forward difference approximation of derivatives, though a central 
difference approximation can be specified in control parameters. 
We are unclear why `numericDeriv()` in base R calls `C_numeric_deriv`,
as we were easily able to create a more compact version entirely in R. 
See *https://github.com/nashjc/RNonlinearLS/tree/main/DerivsNLS*.

`minpack.lm::nlsLM()` invokes `numericDeriv()` in its local 
version of `nlsModel()`, but it appears to use an internal approximate Jacobian 
code from 
the original Fortran `minpack` code, namely, `lmdif.f`. Such differences in approach
can lead to different behaviour, usually minor, but sometimes annoying with
ill-conditioned problems. 

- A pasture regrowth problem (@Huet2004, page 1, based on @Ratkowsky1983) has a
  poorly conditioned Jacobian and `nls()` fails with "singular gradient". 
  Worse, numerical approximation to the Jacobian gives the error
  "singular gradient matrix at initial parameter estimates" for `minpack.lm::nlsLM`
  so that the Marquardt stabilization is unable to take effect, while the analytic
  derivatives of `nlsr::nlxb` give a solution. 

- Karl Schilling (private communication) provided an example where a model specified
  with the formula `y ~ a * (x ˆ b)` causes `nlsr::nlxb` to fail because the partial
  derivative w.r.t. `b` is `a * (x^b * log(x))`. If there is data for which `x = 0`,
  the derivative is undefined, but the model can be computed. In such cases, 
  we observed that `nls()` and `minpack.lm::nlsLM` found a solution through the 
  lucky accident that the approximate derivative can be evaluated.

### Jacobian code in selfStart models

Analytic Jacobian code can be provided to all the solvers discussed.
Most `selfStart` models that automatically provide starting parameters
also include such code. There is documentation in R
of `selfStart` models, but their construction is non-trivial. A number 
of such models are included with base R in `./src/library/stats/R/zzModels.R`,
with package `nlraa` (@MiguezNLRAA2021) providing a richer set. 
There are also some in the now-archived package `NRAIA`.
The Jacobian is provided via the `gradient` attribute of the "one-sided" formula
that defines each model, and these Jacobians are often the analytic forms. 

The `nls()` function, after
computing the "right-hand side" or `rhs` of the residual, checks to see if the
`gradient` attribute is defined, otherwise using `numericDeriv()` to compute a 
Jacobian into that attribute. This code is within the `nlsModel()` or
`nlsModel.plinear()` functions. The use of analytic Jacobians
almost certainly contributes to the good performance of `nls()` on `selfStart` 
models.

The use of `selfStart` models with
`nlsr` is described in the "Introduction to nlsr" vignette. However, since `nlsr`
generally can use very crude starting values, we have rarely needed them, though
it should be pointed out that our work is primarily diagnostic. If we were carrying
out a large number of similar estimations, such initial parameters are 
critical to efficiency.

In considering `selfStart` models, we noted that the base-R function `SSlogis`
is intended to solve problem **Logistic3T** above.  When this function is used
via `getInitial()` to  find
starting values, it actually calls `nls()` with the 'plinear' algorithm 
and finds a (full) solution. It then passes the solution coefficients to the default 
algorithm which converges in one iteration and builds the standard output. 
We found the implicit double-call a challenge to unravel. 
A more conventional approach to starting parameters, following the lead of @Ratkowsky1983, 
is in the function `SSlogisJN`, now part of the package `nlsr`.

Users may also want to profit from the Jacobian code of `selfStart` models 
but supply explicit starting values other than those suggested by `getInitial()`.
This does not appear to be possible with `nls()`. `nlsr::nlxb()` always requires 
starting parameters. We could get these by separately calling `getInitial()` to 
find them from the `selfStart` model, but could use other values. The `selfStart` 
model is also used in the formula for the `nlxb()` call.

<!-- tssx <-try(nls(weed ~ SSlogis(tt, Asym, xmid, scale), start=stt1, data=weeddf)) -->
<!-- tssx <-try(nls(weed ~ SSlogis(tt, Asym=1, xmid=1, scale=1),  data=weeddf)) -->
<!-- tssx <-try(nls(weed ~ SSlogis(tt, Asym, xmid, scale),  data=weeddf))summary(tssx) -->

We note that the analytic expressions for the Jacobian (`gradient`) in the `SSLogis` 
function and others save quantities by default in "hidden" variables, i.e., with 
names preceded by ".".  This behaviour is to avoid name 
conflicts with user quantities. Hidden variables are not displayed by the `ls()` 
command, so users need to remember to use `ls(all.names = TRUE)` to see which quantities
are defined, for example, in developing their own selfStart model via copy and edit.

Interactive tools, such as "visual fitting" (@nash1996nonlinear) might be
worth considering as another way to find starting parameters, but we know of no
R capability of this type.

As a side note, the introduction of `scaleOffset` in R 4.1.1 to deal with the 
convergence test for small residual problems now requires that the `getInitial()`
function have dot-arguments (`...`) in its argument list. This illustrates the
entanglement of many features in `nls()` that complicate its maintenance and
improvement.

## Bounds constraints on parameters

For many problems, we know that parameters cannot be bigger or smaller than some
externally known limits. Such limits should be built into models, but there 
are some important details for using the tools in R.

- `nls()` can only impose bounds if the `algorithm = "port"` argument is 
used in the call. Unfortunately, the documentation warns us:

  *The algorithm = "port" code appears unfinished, and does not even 
   check that the starting value is within the bounds. Use with 
   caution, especially where bounds are supplied.*

- `gsl_nls()` does not offer bounds.

- bounds are part of the default method for package `nlsr`.

- `nlsLM()` includes bounds in the standard call, but we have observed cases
   where it fails to get the correct answer. From an examination of the code,
   we believe the authors have not taken into account all possibilities, though
   all programs have some weakness regarding constrained optimization in that
   programmers have to work with assumptions on the scale of numbers, 
   and some problems will be outside the scope envisaged.
   
Examples of the use of bounds constraints for nonlinear regression modeling are
quite scarce. Traditionally, workers transform variables to ensure bounds are
satisfied, such as squaring a parameter, or using a parameter which is the $\log()$
of the actual parameter, so that its exponential is positive. These transformations
can create scaling issues, but seem to generally work.

Bounds can also be helpful to avoid unanticipated excursions of the minimization
trajectory into inadmissible parameter regions. Such bounds should not be too
tight, as this may hinder progress to an optimum by causing the methods to 
bump along the constraint in many cycles. Our aim is to avoid rubbish, not
specify where the solution will be, and we hope the solution is not complicated
by having a parameter on a bound.

```{r ex10, echo=TRUE} 
# Start MUST be feasible i.e. on or within bounds
anlshob1b <- nls(frms, start = sts1, data = weeddf, lower = c(0,0,0),
             upper = c(2,6,3), algorithm = 'port')
pnls(anlshob1b) #  check the answer (short form)
# nlsLM seems not to work with bounds in this example
anlsLM1b <- nlsLM(frms, start = sts1, data = weeddf, lower = c(0,0,0), upper = c(2,6,3))
pnls(anlsLM1b)
# also no warning if starting out of bounds, but gets a good answer!!
st4<-c(c1 = 4, c2 = 4, c3 = 4)
anlsLMob <- nlsLM(frms, start = st4, data = weeddf, lower = c(0,0,0), upper = c(2,6,3))
pnls(anlsLMob)
# Try nlsr::nlxb()
anlx1b <- nlxb(frms, start = sts1, data = weeddf, lower = c(0,0,0), upper = c(2,6,3))
pshort(anlx1b)
```

### Philosophical considerations

Bounds on parameters raise some interesting questions about how 
uncertainty in parameter estimates should be computed or reported. That is, the
traditional "standard errors" are generally taken to imply symmetric intervals about
the point estimate in which the parameter may be expected to be found with some
probability under certain assumptions.
Bounds change those assumptions. Hence, `nlsr::nlxb()` does not compute standard
errors nor their derived statistics when bounds are active. Transformations to
implicitly enforce bounds avoid this issue, but at the cost of changing the 
form of the model.

### Fixed parameters (masks)

Let us try to fix (mask) the first parameter in the first two example problems. We might
want to do this if it is considered that the asymptote is known from external sources,
but we wish later to have it available to be estimated.

```{r ex10m, echo=TRUE}
# Hobbsmaskx.R -- masks with formula specification of the problem
require(nlsr); require(minpack.lm); traceval <- FALSE
stu <- c(b1 = 200, b2 = 50, b3 = 0.3) # a default starting vector (named!)
sts <- c(c1 = 2, c2 = 5, c3 = 3) # a default scaled starting vector (named!)
# fix first parameter
anxbmsk1 <- try(nlxb(frmu, start = stu, data = weeddf, lower = c(200,0,0), 
			upper = c(200, 60, 3), trace=traceval))
print(anxbmsk1)
anlM1 <- try(nlsLM(frmu, start = stu, data = weeddf, lower = c(200,0,0), 
			upper = c(200, 60, 3), trace=traceval))
pnls(anlM1)
anlsmsk1 <- try(nls(frmu, start = stu, data = weeddf, lower = c(200,0,0), 
		upper = c(200, 60, 3),  algorithm="port", trace = traceval))
pnls(anlsmsk1)
# Hobbs scaled problem with bounds, formula specification
anlxmsks1 <- nlxb(frms, start = sts, data = weeddf, lower = c(2,0,0),
                  upper = c(2,6,30))
print(anlxmsks1)
anlshmsk1 <- nls(frms, start = sts, trace = traceval, data = weeddf, lower = c(2,0,0),
             upper = c(2,6,30), algorithm = 'port')
pnls(anlshmsk1)
anlsLMmsks1 <- nlsLM(frms, start = sts, data = weeddf, lower = c(2,0,0),
                 upper = c(2,6,30))
pnls(anlsLMmsks1)

# Test with all parameters masked
anlxmskall<- try(nlxb(frms, start = sts, data = weeddf, lower = sts, upper = sts))
print(anlxmskall)
```

`nlsr` has an output format that indicates the constraint status of the parameter
estimates. For `nlsr`, we have **chosen** to suppress the calculation of 
approximate standard errors in the parameters when constraints are active because
their meaning under constraints is unclear, though we believe this 
policy worthy of discussion and further investigation.

## Stabilization of Gauss-Newton computations

All four major tools illustrated solve some variant of the Gauss-Newton 
equations. `nls()` uses a modification of an approach suggested by @Hartley1961,
while `nlsr`, `gslnls`, and `minpack.lm` use flavours of @Marquardt1963. `gslnls`
offers an accelerated Marquardt method and three alternative methods which we
have not investigated beyond one example.
Control settings for `nlxb()` or `nlfb()` allow exploration of Hartley and Marquardt 
algorithm variants, principally for the benefit of program developers. 
In general, the Levenberg-Marquardt stabilization 
is important in obtaining 
solutions in methods of the Gauss-Newton family, as `nls()` terminates 
too frequently and unnecessarily with `singular gradient` errors. A tidy
incorporation of Marquardt stabilization into `nls()` would be a major improvement.

## Programming language

An important choice made in developing `nlsr` was to code entirely within the R 
programming language. `nls()` uses a mix of R, C, and Fortran, as does `minpack.lm`. 
`gslnls` is an R wrapper to various C-language routines in the GNU Scientific 
Library (@GSL-manual).
Generally, keeping to a single programming language can allow for 
easier maintenance and upgrades. It also avoids some work when there are changes 
or upgrades to libraries for the non-R languages. 
R is usually considered slower 
than most computing environments because it keeps track of objects and 
because it is usually interpreted. In recent years, the 
performance penalty for using code entirely in R has been much reduced
with the just-in-time compiler and other improvements. All-R computation 
may now offer acceptable performance. In `nlsr`, the use of R may be a
smaller performance cost than the aggressive approach to a solution,
such as large computational limits for residuals and Jacobians.

There are, of course, problems where use of R code will be slower. For example, a
"large" case of the Penalty 1 test problem of @More1981TUO will take
noticeable time to solve. Problems in large numbers of parameters
create large computational matrices for the Jacobian or its inner product,
which Gauss-Newton methods create and process. 
This is confirmed by comparing `nlsr::nlfb()` and `minpack.lm::nls.lm()` on
the Penalty 1 problem of various sizes, where the latter, which uses 
compiled Fortran internally, was moderately faster. However, the method
"Rcgmin" from package `optimx` (@p-optimx) proved to be much 
faster than either, despite being entirely written in R, and is a much more
reliable conjugate gradient minimizer than method "CG" of `optim()`. One
of us created both, but now deprecates the latter. 
Timings of CG methods are more sensitive to small differences in
setup and arithmetic than Gauss-Newton methods, and the pattern of
such timings varies much less regularly with problem size for CG methods.

## Data sources for problems

`nls()` can be called without specifying the `data` argument. In this case, it will
search in the available environments (i.e., workspaces) for suitable data objects. 
We do not like this approach, but it is "the R way". R allows users to leave many 
objects in the default (`.GlobalEnv`) workspace. Moreover, users have to actively 
suppress saving this workspace (`.RData`) on exit; otherwise, any such file in 
the path will be loaded on startup. R users in our
acquaintance avoid saving the workspace because of lurking data and
functions that may cause unwanted results.

### Feature: Subsetting

`nls()` and other class `nls` tools accept an argument `subset`. This acts through 
the mediation of `model.frame`, which is not obvious in the 
source code files `/src/library/stats/R/nls.R` and `/src/library/stats/src/nls.C`. 
Having `subset` at the level of the call to a function like
`nls()` saves effort, but it does mean that the programmer of the 
solver needs to be aware of the
origin (and value) of objects such as the data, residuals and Jacobian. 
By preference, 
we would implement subsetting by zero-value weights, with observation counts
(and degrees of freedom) computed via the numbers of non-zero weights. Alternatively,
we would extract a working dataframe from the relevant elements in the original.

### Feature: na.action (missing value treatment)

`na.action` is an argument to the `nls()` function, but it does not appear 
obviously in the source code, often being handled behind the scenes after 
referencing the option `na.action`. This feature also changes the data 
supplied to our nonlinear least squares solver. 
A useful, but possibly dated, description is given in:
*https://stats.idre.ucla.edu/r/faq/how-does-r-handle-missing-values/*.
The typical default action, which can be seen by using the command
`getOption("na.action")`
is `na.omit`. This option removes from computations any observations
containing missing values (i.e. any row of a data frame containing an NA). 
`na.exclude` does much of the same for solver computations, but keeps the rows with 
NA elements so that predictions are in the correct row position. We recommend that 
workers actually test output to verify the behaviour is as wanted.
See *https://stats.stackexchange.com/questions/492955/should-i-use-na-omit-or-na-exclude-in-a-linear-model-in-r*.
As with `subset`, our concern with `na.action` is that users may be unaware of the
effects of an option they may not even know has been set. Should `na.fail` be the default?

## Model frame

`model` is an argument to the `nls()` and related functions, which is documented as:

  ***model** logical. If true, the model frame is returned as part of the object. Default is FALSE.*

Indeed, the argument only gets used when `nls()` is about to return its result
object, and the
element `model` is NULL unless the calling argument `model` is TRUE. (Using the same 
name could
be confusing.) Despite this, the model frame is used within the function code in 
the form of the object
`mf`. We feel that users could benefit from more extensive documentation and 
examples of its use since it is used to implement features like `subset`. Moreover,
it provides access to resources that may be important in further calculations on
models.

## Weights on observations

All four main tools we consider here allow a `weights` argument that
specifies a vector of fixed weights the same length as the number of residuals. 
Each residual is multiplied by the square root of the corresponding weight. 
Where available, the values returned by the
`residuals()` function are weighted, and the `fitted()` or `predict()` functions are 
used to compute raw residuals.

While fixed weights may be useful, there are many problems for which
we want weights that are determined at least partially from the model 
parameters; for
example, a measure of the standard deviation of observations.
Such dynamic weighting situations are discussed in the vignette 
"Introduction to nlsr" of package `nlsr` in section 
*Weights that are functions of the model parameters*.
`minpack.lm` offers a function `wfct()` to 
facilitate such weighting. Care is advised
in applying such ideas.

### Weights in returned functions from nls()

The function `resid()` (an alias for `residuals()`) gives weighted residuals, 
as does, for example, `result$m$resid()`. The function `nlsModel()`, which we 
have had to extract from the base R code and explicitly `source()` because it 
is not exported to the working namespace,
allows us to compute residuals for particular coefficient sets.

```{r nlswtx, echo=TRUE}
wts <- 0.5 ^ tt # simple weights
frmlogis <- weed ~ Asym/(1 + exp((xmid - tt) / scal))
Asym <- 1; xmid <- 1; scal <- 1
nowt <- nls(weed ~ SSlogis(tt, Asym, xmid, scal)) # unweighted
rnowt <- nowt$m$resid() # This has unweighted residual and Jacobian. Does not take coefficients.
attr(rnowt, "gradient") <- NULL; rnowt
usewt <- nls(weed ~ SSlogis(tt, Asym, xmid, scal), weights=wts)
rusewt <- usewt$m$resid() # weighted. Does not take coefficients.
attr(rusewt,"gradient") <- NULL; rusewt
source("nlsModel.R")
nmod0 <- nlsModel(frmlogis, data = weeddf, start = c(Asym = 1, xmid = 1, scal = 1), wts = wts)
rn0<-nmod0$resid() # Parameters are supplied in nlsModel() `start` above.
attr(rn0,"gradient") <- NULL; rn0
nmod <- nlsModel(frmlogis, data = weeddf, start = coef(usewt), wts = wts)
rn <- nmod$resid()
attr(rn,"gradient") <- NULL; rn
```

## Minor issues with nonlinear least-squares tools

### Interim output from the "port" algorithm

As the `nls()` **man** page states, when the "port" algorithm is used with the
`trace` argument TRUE, the iterations display the objective function value which 
is 1/2 the sum of squares (or deviance). The trace display is likely
embedded in the Fortran of the `nlminb` routine that is called to execute 
the "port" algorithm, but the factor of 2 discrepancy is nonetheless
unfortunate for users. 

### Failure to return the best result achieved

If `nls()` reaches a point where it cannot continue but has not found a point 
where the relative offset convergence criterion is met, it may simply exit,
especially if a "singular gradient" is found. However, 
this may occur **after** considerable progress has been made in reducing 
the sum of squared residuals. 
<!-- An example is to be found in the `Tetra_1.R` example from the `nlsCompare` package. -->
<!-- ?? AB: Are we far enough along to include reference? -->
Here is an abbreviated example:

```{r tetrarun}
time <- c(1,  2,  3,  4,  6 , 8, 10, 12, 16)
conc <- c(0.7, 1.2, 1.4, 1.4, 1.1, 0.8, 0.6, 0.5, 0.3)
NLSdata <- data.frame(time,conc)
NLSstart <- c(lrc1 = -2, lrc2 = 0.25, A1 = 150, A2 = 50) # a starting vector (named!)
NLSformula <- conc ~ A1 * exp(-exp(lrc1) * time) + A2 * exp(-exp(lrc2) * time)
tryit <- try(nls(NLSformula, data = NLSdata, start = NLSstart, trace = TRUE))
# print(tryit) # gives no information on best sumsquares or model parameters
```

Note that the sum of squares has been reduced from 61216 to 1.6211, but 
unless `trace` is invoked, the user will not get any information about this.
This almost trivial change to the `nls()` function could be 
useful to R users.

## Estimating models that are partially linear

The variable projection method (@Golub1973, @OlearyRust13) is 
usually much more effective than general approaches in finding good solutions 
to nonlinear least squares 
problems when some of the parameters appear linearly. In our logistic examples, 
the asymptote parameters are an illustration. However, identifying which parameters
are linear and communicating this information to estimating functions 
is not a trivial task. `nls()` has an option `algorithm = "plinear"` that allows some partially linear
models to be solved. The other tools, as far as we are aware, do not offer any
such capability. The `nlstac` package uses a different algorithm for similar goals.

Within `nls()` itself we must, unfortunately, use
different specifications with different `algorithm` options.
For example, the explicit linear model `y ~ a * x + b` does not work. As with 
the linear modeling function `lm()`, this must be specified as `y ~ x`.
Within `nls()`, consider the following four different specifications for the same 
problem, plus an intuitive choice, labeled `fm2a`, that does not work. 
In this failed attempt, putting the `Asym` parameter in the model causes the
`plinear` algorithm
to try to add another term to the model. We believe this is unfortunate, and would
like to see a consistent syntax. We do not foresee a resolution for this issue, which
arises from different approaches to model specification. In the example, we have not evaluated
the commands to save space.

```{r log4ways, echo=TRUE, eval=FALSE}
DNase1 <- subset(DNase, Run == 1) # select the data
## using a selfStart model - do not specify the starting parameters
fm1 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
summary(fm1)

## using conditional linearity - leave out the Asym parameter
fm2 <- nls(density ~ 1 / (1 + exp((xmid - log(conc)) / scal)),
                 data = DNase1, start = list(xmid = 0, scal = 1),
                 algorithm = "plinear")
summary(fm2)

## without conditional linearity
fm3 <- nls(density ~ Asym / (1 + exp((xmid - log(conc)) / scal)),
                 data = DNase1,
                 start = list(Asym = 3, xmid = 0, scal = 1))
summary(fm3)

## using Port's nl2sol algorithm
fm4 <- try(nls(density ~ Asym / (1 + exp((xmid - log(conc)) / scal)),
                 data = DNase1, start = list(Asym = 3, xmid = 0, scal = 1),
                 algorithm = "port"))
summary(fm4)

## using conditional linearity AND Asym does not work
fm2a <- try(nls(density ~ Asym / (1 + exp((xmid - log(conc)) / scal)), 
                 data = DNase1, start = list(Asym=3, xmid = 0, scal = 1),
                 algorithm = "plinear", trace = TRUE))
summary(fm2a)
```

## Models with indexed parameters

Some models have several common parameters and 
others that are tied to particular cases. 
The **man** file for `nls()` includes an example of a situation in which
parameters are indexed but which uses the "plinear" option as an added complication.
Running this example reveals that the answers for the parameters are not indexed
as in a vector. 
<!-- e.g. `coef(musc.2)` is a single level vector of parameters.  -->
That is, we do not see `a[1], a[2], a[3]` but `a1, a2, a3`. 
<!-- This is because the model -->
<!-- must integrate all the parameters because `th` is a common parameter across the index `Strip`. -->
This is no doubt because programming for indexed parameters is challenging.
<!-- However, we believe the current structure could cause confusion and error, and  -->
<!-- propose an alternative approach below. -->
We note that there are capabilities in packages for mixed-effects modeling
such as `nlme` (@p-nlme), `bbmle` (@p-bbmle), and `lme4` (@p-lme4) for 
estimating models of such type.


## Some other CRAN packages for nonlinear modeling

`onls` (@R-onls-manual) -- The usual optimization in estimating nonlinear models
is the vertical difference between the dependent variable and the functional
model. `onls` minimizes the sum of **orthogonal** residuals. The objective is
therefore different and involves nontrivial extra calculation. A vignette with
the package and the blog article 
https://www.r-bloggers.com/2015/01/introducing-orthogonal-nonlinear-least-squares-regression-in-r/ 
give some description with illustrative graphs. `onls` appears to be limited to 
problems with one independent and one dependent variable. The Wikipedia article
https://en.wikipedia.org/wiki/Total_least_squares presents an overview of some
ideas, with references to the literature. The approach needs a wider 
discussion and tutorial examples to allow its merits to be judged than can be
included here.

`crsnls` (@R-crsnls-manual) -- This package allows nonlinear estimation by 
controlled random search via two methods. There is unfortunately no vignette.
A modest trial we carried out showed `nlsr::nlxb()` gave the same results in 
a small fraction of the time required by either of the methods in `crsnls`. The
method discussed in @tvrdik2007 claims better reliability in finding solutions
than a Levenberg-Marquardt code (actually from Matlab), but the tests were conducted
on the extreme NIST examples mentioned next.

`NISTnls` (@NISTnls-manual) -- This package provides R code and data for a set of
(numerically ill-conditioned) nonlinear least squares problems from the U.S. National 
Institute for Standards and Technology. These may not represent real-world situations.

`nlshelper` (@nlshelper-manual) -- This package, which unfortunately lacks a
vignette, provides a few utilities for summarizing, testing, and plotting 
non-linear regression models estimated with nls(), nlsList() or nlme() that
are linked or grouped in some way. 

`nlsic` (@nlsic-manual) -- This solves nonlinear least squares problems with optional
equality and/or inequality constraints. It is clearly **not** about modeling, and
the input and output are quite different from class `nls` methods. However, there do
not appear to be other R packages with these capabilities.

`nlsMicrobio` (@nlsMicrobio-manual) -- Data sets and nonlinear regression models 
dedicated  to predictive microbiology, including a vignette, by authors of the
`nlstools` package.

`nlstools` (@p-nlstools) -- This package provides several tools for aiding the estimation 
of nonlinear models, particularly using `nls()`. The vignette is actually a journal
article,  and the authors have considerable experience in the subject.

`nlsmsn` (@m-nlsmsn) -- Fit univariate non-linear scale mixture of skew-normal(NL-SMSN) 
regression, with details in Garay, Lachos, and Abanto-Valle (2011). The problem 
here is to minimize an objective that is modified from the traditional sum of squared
residuals.

`nls.multstart` (@nlsmultstart) -- Non-linear least squares regression using
AIC scores with the Levenberg-Marquardt algorithm using multiple starting values 
for increasing the chance that the minimum found is the global minimum.

`nls2` (@nls2-22) -- Nonlinear least squares by brute force has similar
motivations to `nls.multstart`, but uses `nls()` within multiple trials. The author
has extensive expertise in R.

`nlstac` (@m-nlstac) -- A set of functions implementing the algorithm described in
Fernandez Torvisco et al. (2018) for fitting separable nonlinear regression curves. The 
special class of problem for which this package is intended is an important and 
difficult one. No vignette is provided, unfortunately.

`easynls`  -- Fit and plot some nonlinear models. Thirteen models are treated, but 
there is minimal documentation and no vignette. Package `nlraa` is to be preferred.

`nlraa`  (@MiguezNLRAA2021) -- a set of nonlinear *selfStart* models, primarily from
agriculture. Most include analytic Jacobian code.

`optimx` (@p-optimx) -- This provides 
optimizers that can be applied to minimize a nonlinear function which could be
a nonlinear sum of squares. This is not generally recommended if nonlinear 
least squares programs can be easily used, but provides a check and alternative
solvers.


## Tests and use-case examples

Maintainers of packages need suitable tests and use-case examples in order

- to ensure packages work properly, in particular, giving
results comparable to or better than the functions they are to replace. 
- to test individual solver functions to ensure they work across the range of 
  calling mechanisms, that is, different ways of supplying inputs to the solver(s);
- to pose "silly" inputs to see if these bad inputs are caught by the programs.
  
Such goals align with the aims of **unit testing** 
(@HWtestthat11, @HWdevtools21, the conventional R package testing tools, and 
a number of blog posts found by searching "unit testing in R").
In our work, one of us has developed a working prototype package at *https://github.com/ArkaB-DS/nlsCompare*.
A primary design objective of this is to allow the summarisation of multiple tests in
a compact output. The prototype has a vignette to illustrate its use.

## Future of nonlinear model estimation in R

Given its importance to R, it is possible that `nls()` will remain more or less 
as it has been for the past several decades. If so, the focus of discussion 
should be the measures needed to secure its continued operation for legacy 
purposes and how that may be accomplished. 
We welcome an opportunity to participate in such conversations. 

To advance the stability and maintainability of R, we believe the program 
objects (R functions)
that are created by tools such as `nls()` should have minimal 
cross-linkages and side-effects.
The aspects of `nls()` that concern us follow.

- R tools presume data and parameters needed are available in an 
  accessible environment. This provides a compact syntax to invoke the
  calculations, but the wrong data can be used if the 
  internal search finds a valid name that is not the object we want, 
  or if `subset` or `na.action` settings modify the selection, or 
  `weights` are applied.

- Mixing of R, C and Fortran code adds to the burden of following the 
  program logic.

- The class `nls` structure simplifies calls with its rich set of functions, but
  also adds to the task of understanding what has been done. A design that isolates
  the setup, solution, and post-solution parts of complicated calculations reduces 
  the number of objects that must be kept in alignment. 
  
Given the existence of examples of good practices such as analytic derivatives, 
stabilized solution of Gauss-Newton equations, and bounds-constrained parameters, 
base R tools should 
be moving to incorporate them. These capabilities are available now by 
using several tools, but it would be helpful if they were unified.

# Acknowledgments

Hans Werner Borchers was helpful in developing the GSoC project motivating this article
and in comments on this and related work. Heather Turner co-mentored the project 
and helped guide the progress of the work. Exchanges with Fernando Miguez helped to
clarify aspects of `selfStart` models and instigated the "Introduction to nlsr" 
vignette. Colin Gillespie (package `benchmarkme`) has been helpful in guiding our 
attempts to succinctly summarize computing environments. Particularly thoughtful
reviews by the referees, including details of inner workings of R, 
have led to important revisions.


# References


