---
title: "A Machine Profile Summary"
author: 
   - John C. Nash \thanks{ retired professor, Telfer School of Management, University of Ottawa}
   - Arkajyoti Bhattacharjee \thanks{Department of Mathematics and Statistics, Indian Institute of Technology, Kanpur}
date: "14/06/2021 revised 18/01/2022"
bibliography: ../BibSupport/ImproveNLS.bib
output: 
  pdf_document:
    keep_tex: false
---

<!-- date: "`r format(Sys.time(), '%d %B, %Y')`" -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Providing a characterization of a particular computing environment for R calculations

If we want to compare results computed on different machines, we need a way to provide 
measures and identifiers of the particular computing environment at hand. This write-up
attempts to summarize some possibilities available in the R statistical software and language.
Note that one of our interests is to have tools that work in R **across different platforms**.
That is, we want to be able to call an R function to get machine and computing environment
characterizations regardless of the particular platform which we are currently using.
Moreover, we want to have a succinct output of such information.

# Some possible information desired

There are multiple ways to get information of the type useful for characterizing the
computing infrastructure used for a particular test or timing. However, we need to
ensure that identifiers of particular pieces of information are unique, and that 
common identifiers really do specify identical, or at least equivalent, information. 
Otherwise, new names for some pieces of our set of capability information are needed.

## Temporal information

When we wish to analyze performance results, it is extremely helpful to have 
information on when the calculations were performed. 
Most computations should have a time/date stamp that is unlikely to be confused with any
other, at least in combination with a machine name and/or other tags. Here is one
suggestion based on the R `Sys.time()` function.

```{r tdstamp}
#get a timestamp
tsstr<- format(Sys.time(), "%Y/%m/%d|%H:%M") # tsstr == time stamp string in form YYYYmmddHHMM
cat("Date and Time stamp:",tsstr,"\n")
```

## Identifier for the computing software environment

Some of the important information elements concerning the computing environment that 
we need for reporting tests are

- a machine name. While most systems (and Linux in particular) offer to let the user
  provide a machine name, there are generally defaults that many people accept, and
  these are often uninformative and may be non-unique. We note that VirtualBox with
  a Windows 10 guest machine gave the name DESKTOP-HF4CKVA. Where this name was 
  generated we are not sure. Settings / System allows "rename this PC".
  
- operating system and version. For Linux systems, we note that besides the distribution
  variant, e.g., Linux Mint 20.3 MATE 64 bit, it is necessary to add the Linux kernel
  identifier, e.g.,  5.13.0-25-generic, from the `uname` command. 

- compiler or interpreter version. For our needs, it is obvious that the R version
  will be important. However, if any code is compiled or linked to libraries, we
  would like to know that. In particular, versions of compilers (e.g., gfortran, 
  gcc) or BLAS or LAPACK libraries used will affect performance. Linux generally
  displays the BLAS and LAPACK **filenames** in `sessionInfo()`, but to get the
  version information, one needs to dig deeper, for example, using operating
  system commands. For the present, we will omit such extra information unless
  we can extract it easily within R.
  
- specific variations, if any, that should be noted. Here we may want to note if
  a machine is running background tasks, or if some special steps have been 
  taken to speed up or slow down the operation e.g., overclocking.
  
## Hardware information

Some of the factors relating to hardware that could be important are:

- cpu (i.e., processor)
- number of cores
- operating cycle speed (this is sometimes specific to the cpu specified )
- RAM size total
- RAM size available, possibly indicating swap space and usage
- RAM speed (which could be variable)
- GPU (i.e, additional processors) information. 

## Software information

Clearly it is important to identify which software packages are active, and the
R `sessionInfo()` command is useful for this. However, there may be additional 
features that should be mentioned if the user has modified the software in any
way.

The use of tools to carry out computations in parallel, using multiple cores or
GPUs, is clearly an issue. In our opinion, such possibilities are not well supported
by common R functions, or indeed in other computing languages, though we would very
much like to hear of tools to provide such information.

# R tools for machine information

## sessionInfo()

```{r sessionInfox}
si <- sessionInfo()
si <- as.vector(si)
si
```

## benchmarkme

An important tool for acquiring machine information is the CRAN package
`benchmarkme` (@benchmarkme). We found a minor bug in the `get_ram()`
function of this package for some Windows 10 versions which is now 
corrected on https://github.com/csgillespie/benchmarkme, but at the 
time of writing is not yet on the CRAN repository. ??Do we wish to comment on the
"GB" issue?

?? Need to comment on 

- uses `proc.time()` for timings
- has single core and parallel timings
- ?? does it do GPUs
- provides far too much for most needs i.e., a succinct summary of
  how capable a computing system should be

```{r benchmarkmex}
library(benchmarkmeData)
library(benchmarkme)
ls(package:benchmarkmeData)
ls(package:benchmarkme)
lsf.str("package:benchmarkme")
lsf.str("package:benchmarkmeData")
## This next line takes a lot of time to run, so is commented out here
# benchmark_std()
get_byte_compiler()
gla<-get_linear_algebra()
gsd<-get_sys_details()
```


## Calculating the machine precision

Until the IEEE 754 standard (??ref) became availaible in the 1980s, 
computers used multiple forms of floating point arithmetic. With
some ingenuity, it is possible to detect many aspects of the 
floating point properties.
This is a port of Mike Malcolm's ENVRON to R. ??ref. It computes the 
machine precision, radix and number of radix digits. 

?? mention Kahan's Paranoia

```{r envrontest}
envron<-function(){
D1<-as.numeric(1) # use variable to avoid constants when double precision invoked
E5 <- 10 #arbitrary scaling for additive equality tests
B9 <- 1E+35 # big number, not necessarily biggest possible
E6 <- 1 # initial value for radix 
E9 <- 1 # initial value for machine precision
D0 <- E6 
repeat{
  E9 <- E9/2 #start of loop to decrease estimated machine precision
  D0 <- E6+E9 #force storage of sum into a floating-point scalar
  if (D0 <= E6) break
} # repeat reduction while (1+E9) > 1
E9 <- E9*2 # restore smallest E9 which gives (1+E9) > 1
repeat {
   E6 <- E6+1 # try different radix values
   D0 <- E6+E9
   if (D0 <= E6) break
} # until a shift is observed
J1 <- 1 # initial count of radix digits in mantissa
E9 <- 1 # use radix for exact machine precision
repeat {  
  E9 <- E9/E6 #loop while dividing by radix
  J1 <- J1+1 #increment counter
  D0 <- D1+E9 #add tp 1
  if (D0<=D1) break #test and repeat until equality
}
E9 <- E9*E6 #recover last value of machine precision
J1 <- J1-1 #and adjust the number of digits
mpvals<-list(eps=E9, radix=E6, ndigits=J1)
}
mp<-envron()
E9<-mp$eps
E6<-mp$radix
J1<-mp$ndigits
cat("E9 = ",E9,"  -- the machine precision,  E9=MIN (X  1+X>1)\n")
cat( "E9*1E+16=",E9*1E+16,"\n")
cat( "E6 = ",E6,"  -- the radix of arithmetic","\n")
cat( "J1 = ",J1,"  -- the number of radix digits in mantissa of FP numbers","\n")
cat( "E6^(-J1+1) * 1E+16=",1E+16*(E6^(-J1+1)),"\n")
cat(".Machine$double.eps=",.Machine$double.eps,"\n")
cat("From R  .Machine:\n")
cat("double.eps=", .Machine$double.eps,"\n", 
    "double.base=", .Machine$double.base,"\n", 
    "double.digits=", .Machine$double.digits,"\n" )
```

## Simple performance examples

There are many performance examples used for testing the speed of computers. A 
well-known example is the @linbench03 LINPACK test used for ranking supercomputers.
These generally employ linear algebra calculations. The example below, by
contrast, focuses on the special function computations. Variations on this
simple performance test have been used by one of the authors for nearly half
a century. Note the use of the `microbenchmark` timing package (@microbench13).

```{r loopesc}
loopesc <- function(nn){
  ss<-0
  for (i in 1:nn) {
    xx<-exp(sin(cos(1.0*i)))
    ss<-ss+xx
  }
  xx
}
require("microbenchmark")
nvals<-c(1000, 10000, 100000, 1000000)
tvals<-rep(NA,length(nvals))
i<-0
for (nn in nvals) {
  i<-i+1
  cat(nn,"\n")
  tt<-microbenchmark(loopesc(nn), unit='us')
  print(tt)
  tvals[i]<-mean(tt$time)
}
plot(log10(nvals),log(tvals))

```


## Sys.info()

```{r sysinfox}
Sys.info()
```

## Issues relating to random number generation

## Issues relating to compilation of R 

- LAPACK
- BLAS
- others?


# Tools for accessing and clearing environments and dataframes

?? should this be here -- probably to list things in the workspace

```
sys.frame()
sys.frames()
sys.status()
sys.on.exit()
sys.parents()
sys.calls()
```
# Choices

For use in recording tests of R functions and packages for optimization and nonlinear 
least squares, it seems that the `benchmarkme` function `get_sys_details()`
provides more than sufficient information for our needs. 

From the above discussion, the following offers a possible compact solution. Users may
wish to modify this to their own particular needs.

```{r code=xfun::read_utf8('MachID.R')}
```

Note that we are reading from the file `MachID.R` so that this file is usable elsewhere
and the current document does not become out of sync with the working MachID.


## References


